[{"authors":null,"categories":null,"content":"Hello! I’m Alex, a computer science and physics student at the University of British Columbia graduating in 2024. My interests include embedded and application development, machine learning, and numerical methods.\nI’m currently a software engineer intern on the passive safety team at Tesla, and the lead teaching assistant for CPSC 110, UBC’s major-stream introductory computer science course, where I am responsible for many of our internal systems. In my free time, I contribute to the UBC Rocket design team as a member of the avionics subteam, enjoy some light reading, and work on various side projects. I also both help plan and volunteer at UBC’s annual Physics Olympics competition.\nIn the past, I’ve worked as a software engineer intern at Kepler Communications and a numerical methods research assistant in UBC’s Numerical Linear Algebra Lab.\nI’m not currently looking for co-op opportunities, but I am starting to look for new grad roles beginning in May 2024.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"fb8642c15ff4dbaaac61f294f407e6eb","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Hello! I’m Alex, a computer science and physics student at the University of British Columbia graduating in 2024. My interests include embedded and application development, machine learning, and numerical methods.","tags":null,"title":"Alex Steele","type":"authors"},{"authors":[],"categories":[],"content":"This past winter term, I completed CPSC 320: Intermediate Data Structures and Algorithms and, upon writing my customary reflection after finals ended, I began to notice how smoothly my group work in the course went. CPSC 320 had biweekly (i.e. fortnightly, not semiweekly) problem sets that could be worked on alone or in groups of up to three students. It was recommended, but not mandated, that we work in pairs, so I partnered with a fellow CPSC 110 teaching assistant (and a very old friend) for all five assignments. When collaborating on the homework, we adopted a workflow that, upon further discussion with our peers, turned out to be somewhat abnormal, albeit highly effective.\nThe workflow that I would deem the “classic model” for group homework assignments consists of the group members dividing up the problems between themselves and solving them independently, essentially reducing one homework set into two or more. There are three major flaws with this model. First, it is seldom possible to divide up the workload perfectly, even if you make the unrealistic assumption that a question’s difficulty can be objectively determined. Some questions may be harder than others and some partners may rate certain problems’ difficulties asymmetrically. This makes it easy for one partner (or multiple) to resent a real or perceived gap in effort among his or her fellow group members. Second, even if it were possible for a group to perfectly balance the assigned questions, those questions were likely assigned for a reason. When homework is divided up like this, important content can easily be missed, which can come back to bite on exams. Finally, since this model often involves hastily combining the partners’ individual contributions with minimal work to edit them, it can easily result in subpar marks with one person clearly at fault. This can easily reduce group cohesion in the future.\nAnother common model for collaboration is simply doing the entire assignment together. This obviously rectifies any inequalities resulting from splitting the work, but it also completely eliminates most of the advantages of working in a group. A group working together for the entire assignment is essentially just solo work with group members cross-checking each other, and with drastically limited meeting times. My partner and I were both very busy people, and I would dare say that neither of us strictly needed the other to get hundreds on each of the assignments. Because of this, we based our approach on the more conventional model of splitting the workload, with some caveats.\nOur workflow for collaborating on homework had three main principles, each of which roughly corresponded to a phase of our process. Our goals were threefold: to reduce our workloads, to miss as few learning opportunities as possible, and to ensure that our individual standards for quality were satisfied.\nThe first principle of the strategy we adopted was that any learning in the homework assignment should be serialized. That is, we had to ensure that any key content was experienced by both of us, simultaneously, so we could both have the experience of actively thinking about and solving each problem. To accomplish this, my partner and I would either meet in person or call over Zoom the night after each homework assignment was released. During these meetings, we worked through the entire assignment together, looking to find the key insights for each question and note them down for later. We took notes and screenshots of these “sketches” of the proofs and algorithms we would later write.\nSecond, we sought to parallelize the “grunt work” of writing proper pseudocode and formal proofs for all of our sketches from earlier. At the end of our calls, we divided the assignment between ourselves, taking into account our relative proficiencies and the difficulty of each problem. Over the next week, we would separately make contributions to a shared LaTeX document, steadily completing the assignment.\nThe third and most important principle of our workflow was to share full accountability for all the work we submitted jointly. We achieved this by thoroughly examining our entire solution and ensuring that everything was up to both of our standards. We made changes as needed to ensure that we were both comfortable with what we were about to hand in and implicitly agreed that, if we lost marks on anything, the fault would lie with both of us, not just the original author of the error.\nI’m under no delusion that this is a particularly deep insight. Indeed, I’ve practiced variations of it for my entire university career. That said, I decided it was worth a quick write-up after participating in many redundant conversations about the supposed incompatibility between group work and learning from homework, or between group work and getting a good mark. With a rather simple change in workflow, I found that they are quite compatible. By serializing learning, parallelizing grunt work, and …","date":1651881600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1651881600,"objectID":"398b1cc1ffe96ef886570e69654fa460","permalink":"https://alexdsteele.com/post/models-for-collaboration/","publishdate":"2022-05-07T00:00:00Z","relpermalink":"/post/models-for-collaboration/","section":"post","summary":"How does one maximize productivity in group problem sets while minimizing the negative learning and social outcomes involved in group work?","tags":["Academics","Productivity"],"title":"Models for Collaboration","type":"post"},{"authors":[],"categories":null,"content":"I’m asked about how I learned about various topics in my majors with some regularity, so I figured that some might find it helpful if I started to compile a list of learning resources that I found useful. They vary in formality from textbooks and online courses to blogs and videos. I can’t guarantee all of these are necessarily good resources to pick up a new skill or improve an existing one. All I can say is that each of these resources either broadened or deepened my understanding of their respective subjects.\nComputer Science Data Structures and Algorithms Kleinberg and Tardos’ Algorithm Design\nMcDowell’s Cracking the Coding Interview\nComputer Systems Bryant and O’Hallaron’s Computer Systems: A Programmer’s Perspective\nThe YouTube video “Fast Inverse Square Root — A Quake III Algorithm” provides a surprisingly good overview of floating-point number representations.\nNumerical Methods Ascher and Greif’s A First Course in Numerical Methods Machine Learning DeepLearning.AI’s “Deep Learning Specialization” on Coursera provides a decent overview of machine learning techniques, albeit one devoid of much theory.\nRussel and Norvig’s Artificial Intelligence: A Modern Approach\nSutton and Barto’s Reinforcement Learning: An Introduction\nUBC’s machine learning courses have made their materials publically available on GitHub\nDive into Deep Learning is a fairly comprehensive overview of deep neural networks written by a team of Amazon researchers.\nSoftware Engineering Robert “Uncle Bob” Martin, the author of Clean Code and Clean Architecture gave a series of excellent talks on software development and project management that I would highly recommend.\nEven as someone who has never played the game and frankly has little interest in game development, the Factorio development blog has many interesting articles on the development process. I particularly enjoyed reading their articles on optimizations they made to allow the game to run as well as it does.\nProgramming Languages Python Raymond Hettinger’s PyCon 2015 talk “Beyond PEP 8 — Best practices for beautiful intelligible code”\nThe Little Book of Python Anti-Patterns\nC/C++ Koffman and Wolfgang’s Objects, Abstraction, Data Structures and Design: Using C++ Build Systems Craig Scott’s Professional CMake: A Practical Guide\nAn Introduction to Modern CMake\nMathematics General Riley, Hobson, and Bence’s Mathematical Methods for Physics and Engineering provides a good overview of common mathematical techniques and serves its purpose well as a general reference for most math one might end up needing in physics. Calculus James Stewart’s Calculus (or Calculus: Early Transcendentals) was my main resource for learning the subject in AP Calculus AB, AP Calculus BC, and my second year multivariable and vector calculus course. There are many free textbooks available online (UBC’s CLP earns a dishonourable mention), but none of them compare to Stewart’s approachability, intuitiveness, and challenging problems, in my experience.\nSchey’s Div, Grad, Curl, and All That is an excellent supplement to Stewart’s chapters on vector calculus. I found myself consulting it with some regularity in my electricity and magnetism course.\n3blue1brown’s Essence of Calculus\nLinear Algebra Lay’s Linear Algebra and Its Applications\nFriedberg, Insel, and Spence’s Linear Algebra\n3blue1brown’s Essence of Linear Algebra\nProofs Hammack’s Book of Proof\nAigner’s Proofs from THE BOOK\nDifferential Equations Lebl’s Notes on Diffy Qs\nPaul’s Online Math Notes has a decent set of class notes on ordinary differential equations\nBoyce and DiPrima’s Elementary Differential Equations and Boundary Value Problems\nProbability Ross’ Introduction to Probability Models\nAnderson, Seppäläinen, and Valkó’s Introduction to Probability\nPhysics General Feynman’s Six Easy Pieces and Six Not-So-Easy Pieces Elementary Physics Chabay and Sherwood’s Matter and Interactions\nHalliday, Resnick, and Walker’s Fundamentals of Physics\nRelativity Helliwell’s Special Relativity Classical Mechanics Taylor’s Classical Mechanics Thermodynamics and Statistical Mechanics Schroeder’s An Introduction to Thermal Physics Electricity and Magnetism Griffiths’ Introduction to Electrodynamics Quantum Mechanics Griffiths and Schroeter’s Introduction to Quantum Mechanics\nSusskind and Friedman’s Quantum Mechanics: The Theoretical Minimum\n","date":1650067200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1650067200,"objectID":"c6625328e7b2e36b114847f299065f54","permalink":"https://alexdsteele.com/resources/","publishdate":"2022-04-16T00:00:00Z","relpermalink":"/resources/","section":"","summary":"I’m asked about how I learned about various topics in my majors with some regularity, so I figured that some might find it helpful if I started to compile a list of learning resources that I found useful.","tags":null,"title":"Learning Resources","type":"page"},{"authors":[],"categories":[],"content":"Project Fëanor was my term project for PHYS 319: Electronics Laboratory. I designed a quadcopter using mostly 3D-printed parts and used the MSP430 microcontroller as a flight controller, while working within its limited 512 bytes of RAM and 16 kilobytes of memory. To control the four motors, I wrote C code that interfaced with an accelerometer over I2C and accepted commands from a laptop over UART.\n","date":1649116800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1649116800,"objectID":"16ffaa75570d8c2c681bcbddf39be216","permalink":"https://alexdsteele.com/project/project-feanor/","publishdate":"2022-04-05T00:00:00Z","relpermalink":"/project/project-feanor/","section":"project","summary":"MSP430-based Quadcopter","tags":["C","Electronics"],"title":"Project Fëanor","type":"project"},{"authors":[],"categories":null,"content":"In my free time, I enjoy reading books, primarily (but, by no means, exclusively) fantasy, science fiction, and historical non-fiction. Here are some of my favourites, in no particular order:\nJ.R.R. Tolkien’s legendarium (The Hobbit, The Lord of the Rings, The Silmarillion, The Children of Húrin, Beren and Lúthien, The Fall of Gondolin, and Unfinished Tales of Númenor and Middle-Earth) The Wheel of Time series, by Robert Jordan Frank Herbert’s Dune Saga Andy Weir’s works (The Martian, Artemis, and Project Hail Mary) Animal Farm and Nineteen Eighty-Four, by George Orwell Hamlet and Macbeth, by William Shakespeare Pride and Prejudice, by Jane Austen A Tale of Two Cities, by Charles Dickens Moby-Dick, by Herman Melville Pygmalion, by George Bernard Shaw The Great Gatsby, by F. Scott Fitzgerald To Kill a Mockingbird, by Harper Lee Metternich: Strategist and Visionary, by Wolfram Siemann The Guns of August, by Barbara W. Tuchman The Second World War: A Complete History, by Martin Gilbert The Years of Lyndon Johnson, by Robert Caro Becoming, by Michelle Obama A Promised Land, by Barack Obama I’m currently reading:\nThe Letters of J.R.R Tolkien, edited by Humphrey Carpenter The First World War: A Complete History, by Martin Gilbert Foundation, by Isaac Asimov ","date":1647216e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647216e3,"objectID":"6da302e29c14c780e10955c05f7c11ad","permalink":"https://alexdsteele.com/reading/","publishdate":"2022-03-14T00:00:00Z","relpermalink":"/reading/","section":"","summary":"In my free time, I enjoy reading books, primarily (but, by no means, exclusively) fantasy, science fiction, and historical non-fiction. Here are some of my favourites, in no particular order:","tags":null,"title":"Reading","type":"page"},{"authors":[],"categories":[],"content":"UBC’s annual Physics Olympics just happened yesterday. Every year, high schools from across British Columbia send teams of students to compete in a series of physics-themed events. There are a couple of pre-built events, where students design some contraption; a lab event, where they need to apply what they learned to measure some quantity experimentally; Quizzics, where students answer rapid-fire physics and astronomy-related trivia; and Fermi questions, where they apply their knowledge of physics to give order-of-magnitude estimates for various fun problems.\nFermi questions are named after the Italian-American physicist Enrico Fermi, who was famously able to provide order-of-magnitude estimates for seemingly impossible-to-compute figures, like the number of piano tuners in New York City, the blast yield of the Trinity test, or the number of intelligent civilizations in the galaxy with which we could potentially communicate. The objective is to come up with a series of trivial estimates that can be multiplied together to obtain a decent estimate of a highly non-trivial problem.\nThe Fermi questions were always my favourites back when I competed in high school. For the past three years, I’ve helped design and test them. This usually involves me and Rio Weil coming up with a bunch of ideas for different quantities to estimate, then trying to determine different ways to arrive at them. Our criteria for good questions is that they must be non-elementary, robust, and doable on a calculator. By non-elementary, we just mean that it’s not a question one would see in a high school physics textbook where a student could just use a known formula and constants, together with given quantities, to obtain an answer. The solver needs to make a non-obvious estimate, or apply some sort of university-level knowledge. Robustness is determined by whether or not different approaches converge to the same answer. This usually isn’t a problem when questions are specifically-worded enough, but it can still be problematic if the solution is highly sensitive to how one chooses to model the problem. Finally, since students aren’t allowed calculators, we try to ensure that the questions don’t rely on any transcendental functions (save for the trigonometric functions that everyone has memorized) or complicated square roots.\nWe usually come up with a set of problems that trend upward in difficulty. The first question is usually a matter of making one or two (possibly slightly unintuitive) estimates and combining them using simple formulas from high school physics. The last question, however, will typically require students to come up with a more complex model or have knowledge of advanced physics (that a particularly keen AP or IB student might be expected to have).\nI thought it would be interesting to walk through the process of designing a problem. Since all of the problems from yesterday’s event were solved live by Jeorg Rottler at the end of the day, we’ll look at a question that Rio and I tried to make work for a while, but ended up putting aside.\nThe inspiration for this question came from the “Relativistic Baseball” article on xkcd’s What If? blog. I was curious about how quickly a baseball would need to be thrown to replicate the effects described in the article (namely, a small nuclear blast). To be more concrete, I phrased the question as follows:\nHow fast would one need to throw a baseball in order for its impact to release as much energy as the atomic bomb dropped on Hiroshima? Assume no air resistance.\nThe question, in its current state, requires the estimation of two quantities: the mass of a baseball and the yield of Little Boy. This alone does not make for an interesting problem. However, I was hoping that, like in xkcd, special relativity would come into play.\nIn classical mechanics, the kinetic energy of an object is given by the expression $\\frac{1}{2} m v^2$, where $m$ is the mass of the object and $v$ is its velocity. Therefore, solving this problem classically is simply a matter of substituting one’s estimates into $v = \\sqrt{\\frac{2E_{\\text{blast}}}{m}}$, where $E_{\\text{blast}}$ is the yield of the Hiroshima bomb. However, when $v$ is close to the speed of light, this relation breaks down and we must, instead, turn to special relativity.\nThe total relativistic energy of an object is given by $\\gamma m c^2$, where $\\gamma = \\frac{1}{\\sqrt{1 - \\frac{v^2}{c^2}}}$ is the so-called Lorentz factor, which is equal to $1$ for a stationary object and diverges to infinity as $v$ approaches $c$, the speed of light. To obtain the object’s relativistic kinetic energy, we simply subtract off its rest mass energy $E_0 = mc^2$ (this is obtained from the total relativistic energy formula by setting $v = 0$) and obtain $T = E - E_0 = (\\gamma - 1) m c^2$ (as a fun exercise, one can derive the classical $T = \\frac{1}{2} m v^2$ by taking a first-order Taylor approximation of this quantity). Note that we are using relativistic kinetic …","date":1646524800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1646524800,"objectID":"a1c864659ccf3c9eedd8fd52a1f6430b","permalink":"https://alexdsteele.com/post/how-fast-would-one-have-to-throw-a-baseball-to-replicate-a-nuclear-blast/","publishdate":"2022-03-06T00:00:00Z","relpermalink":"/post/how-fast-would-one-have-to-throw-a-baseball-to-replicate-a-nuclear-blast/","section":"post","summary":"A Brief Dive Into the Process of Designing and Testing a Fermi Estimation Question for UBC’s Physics Olympics","tags":["Fermi Questions","Fun","Physics"],"title":"How Fast Would One Have To Throw a Baseball in Order To Replicate a Nuclear Blast?","type":"post"},{"authors":[],"categories":[],"content":"Our project explores the use of GPT-3’s comprehension of code semantics in the setting of CS education. It has two components: a semantic autograder for teachers and a suite of code conversion/documentation tools for students.\nSummary Teacher The main functionality of our project is the semantic autograder. Classically, autograders rely on black-box testing. This approach obviously works well for tasks like grading problem sets and exams but falls short in some other settings. Studies show that active participation in lectures boosts learning outcomes. To encourage this, profs might have students submit code for autograding live in lectures to incentivize participation. However, this can backfire, as the autograder forces students to write perfect code while also being introduced to a topic for the first time, which distracts them from actually learning.\nIdeally, an autograder would be able to tell that a student is writing code that, while not necessarily correct, shows that they understand the problem and roughly know what a solution might look like. To fill this void, we designed a semantics-based autograder. It uses GPT-3 to look at the contents of a student’s code submission and determine how closely it resembles a solution for the given problem. The benefits of using a natural language model, rather than classical text parsing and diffing, to solve this problem are manifest. First, the semantic autograder is able to extract meaning, rather than just structure, from code. This prevents false negatives from similar-looking functions, which can easily arise when a course enforces a common template for certain functions. It also prevents false positives when a problem allows for extremely diverse solutions that can vary wildly from what the instructor expects while still solving the problem.\nStudent In order to guide students in their code implementation and debugging process, our program offers 6 different functions. There are bug fixers, docstring generators and tools to improve code quality and conciseness by converting length for-loops into compact maps or list comprehensions. The docstring generator is very helpful for students to understand the functionality of cryptic and poorly documented code. Moreover, the time complexity calculator can be used as a revision tool by CS students.\nFix Code: Fixes syntactical errors in python code\nTime Complexity: Computes the time complexity of submitted snippet\nPy Docstring: Generates a Doc string for code\nLoop to PyStream: Converts Python for loops into streams\nLoop to List: Deduces the functional programming solution for a given algorithmic solution\nList to Loop: Deduces the iterative solution for a complementary functional programming solution\nTechnology Our implementation uses OpenAI’s Python API and a Flask backend. We considered using Django but felt that it was unncessarily heavy for our use case.\nRunning Unfortunately, OpenAI doesn’t allow projects using GPT-3 to be published without approval, which takes around two weeks. We are, however, allowed to share pre-generated results, as we did in our demonstration video. Additionally, if you have an API key, you are free to run our code and verify our results. Simply clone the repository, add your key as an environment variable named OPENAI_API_KEY, and run comparisons/comparison_functions.py. Here are the expected results:\nfibonacci/starter.py: (105.779, 48.065, -57.714); Passing = False fibonacci/submission_random_garbage.py: (4.357, 3.657, -0.7000000000000002); Passing = False fibonacci/submission_wrong_function.py: (25.971, 18.292, -7.6789999999999985); Passing = False fibonacci/submission_recur.py: (25.715, 33.526, 7.8110000000000035); Passing = True fibonacci/submission_invalid.py: (18.612, 37.666, 19.054); Passing = True fibonacci/submission_indent_error.py: (11.573, 60.106, 48.533); Passing = True fibonacci/solution.py: (10.018, 57.529, 47.511); Passing = True bintree/starter.py: (14.276, 7.852, -6.4239999999999995); Passing = False bintree/submission_iterative.py: (1.316, 3.952, 2.636); Passing = True bintree/submission_alternative.py: (3.74, 5.479, 1.7389999999999999); Passing = True bintree/solution.py: (1.539, 7.248, 5.7090000000000005); Passing = True As we can see, handing in either starter file fails, as does typing random Python code or solving the wrong problem. However, all of the partial attempts at a solution get credit, which is what we want.\n","date":1642291200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1642291200,"objectID":"3113bf5fefaa1ab44ef6d97460ad7eae","permalink":"https://alexdsteele.com/project/au-dela/","publishdate":"2022-01-16T00:00:00Z","relpermalink":"/project/au-dela/","section":"project","summary":"Natural language processing-based tools for computer science education. nwHacks 2022 OpenAI Prize Winner.","tags":["Flask","Machine Learning","Python","Web Development"],"title":"Au Delà","type":"project"},{"authors":[],"categories":[],"content":"Several months ago, I arranged a time to work on a group assignment with another student. After we agreed, I watched him open up his Google Calendar and reveal a many-coloured wall of events spanning the entire week, often continuously from 08:00 to 23:00. As someone who thinks of himself as quite organized and methodical, seeing this left something of an impression on me, as I had never gone into that much detail when scheduling my days before. I first thought it was ridiculous. However, I soon wondered whether adopting such a practice would benefit my studies, why I had decided to go as far as I did down the scheduling rabbit hole, and why I had not gone any further than that. After careful consideration, I can conclude that my gut reaction was correct and that his system is utterly ineffective.\nI first adopted Google Calendar during orientation at the start of first year, to keep track of all of the orientation group meetings, mock lectures, and social events to attend. I found it rather helpful and decided to continue using it throughout first year. I entered all my classes, exams, and office hours into separate calendars and also used a calendar to store events like group study sessions or social gatherings. However, I never blocked out time for assignments or projects. I kept track of all deadlines in Google Tasks, so they’d neatly render on top of my schedule for the week, but I never set aside an hour for a physics assignment or two for a computer science problem set. I never committed to spending four hours reviewing the day before an exam. Doing so would fundamentally conflict with my aim of maximizing my overall average. To explain why, we must first go back a couple of years, then another one hundred and fifty.\nIn the summer of 2019, shortly after I had finished secondary school, I travelled to Europe for the first time with my family. While there, we visited London, Berlin, and Paris for five to seven days each (along with day trips to several other cities). In Berlin, in the heart of Tiergarten, the city’s largest urban park (assuming one does not count the remnants of Templehof Airport as a true park), there stand three statues of the three Prussian statesmen who forged the German Empire. The statue of Otto von Bismarck, the Minister-President of Prussia, looms the largest. Nearby, however, stand two other statues: those of Albrecht von Roon, the Prussian Minister of War, and Helmuth von Moltke, the Chief of the Prussian General Staff.\nStatue of Helmuth von Moltke in Berlin’s Tiergarten Bismarck, the great diplomat, was flanked by these two men of war because Germany was not unified diplomatically, as Great Britain had been, but instead by, in his own words, “iron and blood”. Three wars in the latter half of the nineteenth century propelled Prussia to hegemony: the Dano-Prussian War (often called the Second Schleswig War), the Austro-Prussian War, and the Franco-Prussian War. Roon and especially Moltke were responsible for the military reforms that allowed Prussia and its allies to quickly achieve their aims in those three conflicts.\nMolke was a man obsessed with military planning. As Chief of Staff, he oversaw the writing of formal studies of historical conflicts and current politics, so the General Staff could make better, more relevant plans for Prussia’s future wars. He was an early adopter of the railway and the telegraph for military use, correctly reasoning that if a nation could effectively marshal its railway infrastructure to transport its armies at the outbreak of war, it would have an immense early advantage in the ensuing campaign. Despite all this, however, Moltke is likely most famous in the English-speaking world for one quote:\nThe tactical result of an engagement forms the base for new strategic decisions because victory or defeat in a battle changes the situation to such a degree that no human acumen is able to see beyond the first battle. […] Therefore no plan of operations extends with any certainty beyond the first contact with the main hostile force.\nThis mouthful of a motto is often simply paraphrased as “No plan survives contact with the enemy”. Moltke believed that pre-existing military plans lost much of their value as soon as they were put into action. (Whether he was influenced by the works of Robert Burns when he arrived at this conclusion is unknown to me.) Why, then, did so much of Moltke’s tenure consist of making such plans? In the words of President Dwight Eisenhower, “plans are useless but planning is indispensable”. Plans can never be counted upon, but the process by which they are made is essential preparation.\nYou will almost certainly never make a plan that correctly accounts for every possible factor that could change. (If you do, you ought to be inclined to either play the lottery or never play it again, if you exhibit the hot hand fallacy or the gambler’s fallacy, respectively.) Instead, the key to preparedness is to have several plans that you can …","date":1633651200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1633651200,"objectID":"d4fcc66e1280100df0eb45e67d2a45bb","permalink":"https://alexdsteele.com/post/no-plan-survives-contact-with-the-enemy/","publishdate":"2021-10-08T00:00:00Z","relpermalink":"/post/no-plan-survives-contact-with-the-enemy/","section":"post","summary":"Why I Find Scheduling My Studying To Be Worse Than Useless","tags":["Academics","Productivity"],"title":"No Plan Survives Contact With the Enemy","type":"post"},{"authors":[],"categories":[],"content":"In order to give myself some more tactile experience working with machine learning, I challenged myself to create a bot capable of competing in Generation I Pokemon battles. However, training the bot would still take forever with the only existing option - running a local Pokemon Showdown server and interfacing with it. To solve this problem, I devised Project Lance: a locally-run Python implementation of Generation I Pokemon battles. With it, I was able to run about 2000 full battles per second on my CPU, as opposed to the couple dozen I could run by interfacing with Showdown in that same time. To further improve training speed, I implemented a multicore evaluator for self-play. This allowed me to train a NEAT model to play optimally on a simplified version of the full battle engine.\n","date":162648e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":162648e4,"objectID":"14b99af59e7d831473d5fa4c6649c298","permalink":"https://alexdsteele.com/project/project-lance/","publishdate":"2021-07-17T00:00:00Z","relpermalink":"/project/project-lance/","section":"project","summary":"Desktop Application and NEAT Model for Generation I AI Pokemon battling.","tags":["Machine Learning","Python"],"title":"Project Lance","type":"project"},{"authors":[],"categories":[],"content":"A week or so after my exams finish each term, I find it helpful to write up a brief after action report of sorts for each of my courses, in which I reflect on how effective my various studying practices were. They’re usually each just a couple of pages of bullet points or, at best, disconnected paragraphs that I use when planning out how I will spend my time in future terms. However, in addition to all the expected ups and downs of online learning, my most recent term included my largest upward mark swing in a specific subject so far at UBC. Ergo, I thought it appropriate to formalize my notes on the factors contributing to my performance in MATH 223: Honours Linear Algebra, in an attempt to learn all available lessons from my experiences this term and formalize a strategy to utilize them going forward.\nBackground Before discussing MATH 223, some context is necessary. 223 was not my first experience in an honours mathematics course. Before beginning post-secondary, I was among the strongest math students in my high school. In my enriched pre-calculus and AP Calculus classes, I routinely earned marks in the high nineties and even the occasional hundred, consistently placed among the top scorers in my school in the University of Waterloo math contests, and occasionally helped coach the Math Challengers team in problem-solving techniques. In short, as far as I knew, I was rather strong in mathematics. Consequently, when picking my courses for my first year at UBC, I elected to take MATH 120: Honours Differential Calculus, thinking that it would be a natural progression from high school and that, although it would be a noticeable step up, I would be able to handle it with a moderate level of effort. This presumption proved to be inaccurate.\nThe term started rather well. I found the topics covered challenging but fun. It was a new kind of math and a welcome change of pace from the computational grind of AP Calculus. Going into the first midterm, I had an average of 96% on the first three assignments. I believed that I was quite familiar with the material and would perform relatively well. I wrote the exam and felt my predictions had been accurate. I wasn’t expecting a hundred, but I thought I understood all the questions and gave reasonable answers.\nI was walking across campus one afternoon when my phone buzzed with a notification. It was an email notification from Canvas stating that marks had been posted for the midterm. I clicked on the link, logged in, and saw the first and only C+ that I ever obtained on an exam. The F average was of little consolation. It was blindsiding, it was embarrassing, and it left a scar of self-doubt that would last for the next fourteen months. I had thought that I was adept, if not strong, with the course’s material thus far. When I saw my graded exam, I didn’t see a glut of clerical errors; I saw a series of misunderstandings of concepts, which further compounded my disgust with myself. Every point lost was a massive failure of my studying policies. I knew that major reforms were in order. However, it was too late to fully recover my MATH 120 grade.\nI was able to reverse course over the next month and a half, but that exam dropped my course grade enough to result in my only A- in a course at UBC, and my only non-A+ in a course in what I would consider one of my core subjects (computer science, physics, and mathematics).\nDespite this experience, I signed up for MATH 223: Honours Linear Algebra the following summer. I had been told that the course was more or less necessary if one wished to have a thorough understanding of concepts in upper-year courses, particularly quantum mechanics and machine learning. Deep down, I probably also wanted to prove to myself that the barely-mitigated disaster of MATH 120 was behind me. I knew that it would not be an easy four months. However, this time, I would be prepared.\nThat summer, I began reading ahead and formulating plans on what my studying and homework habits would look like come September. MATH 120 had been my impetus for beginning to write after-action reports like this one, which meant that I had a wealth of notes on and analyses of my study habits from first year. With them, I devised a list of failings that would have to be corrected going forward.\nThe four great mistakes that I took note of were that I had relied too much on my peers, been convinced by my own faulty arguments, lacked a single resource to consult when studying, and overfocused on practice problems to the detriment of general understanding. To amend each of these issues in my study habits, I had to reflect on how I went wrong in MATH 120 and how I would fix things in MATH 223.\nGo it alone. In the first lecture of MATH 120 and more than a few of my other first-year courses, the professor made a point of encouraging us to discuss homework problems with each other (with the obvious caveat that our work had to be our own). In hindsight, this advice was damaging to my …","date":1609286400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1609286400,"objectID":"b207b2517dceb854cba289b8d52936d6","permalink":"https://alexdsteele.com/post/reflections-on-honours-linear-algebra/","publishdate":"2020-12-30T00:00:00Z","relpermalink":"/post/reflections-on-honours-linear-algebra/","section":"post","summary":"An After Action Report on MATH 223","tags":["Academics","Productivity"],"title":"Reflections on Honours Linear Algebra","type":"post"},{"authors":[],"categories":[],"content":"This Swing application allows users to plot events in two-dimensional spacetime. It demonstrates how events transform between reference frames, and how concepts such as simultaneity or two events being in the same place are frame-dependent. Additionally, it allows users to calculate how far two events are from each other in spacetime; whether they are timelike, spacelike, or null separated; and whether they appear to be simultaneous or in the same place in a given frame.\n","date":1606262400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1606262400,"objectID":"b5877875c5c067693d8b1f70cf7df7c6","permalink":"https://alexdsteele.com/project/spacetime-calculator/","publishdate":"2020-11-25T00:00:00Z","relpermalink":"/project/spacetime-calculator/","section":"project","summary":"Java desktop application for solving special relativity problems.","tags":["Java","Swing"],"title":"Spacetime Calculator","type":"project"},{"authors":[],"categories":[],"content":"This is just a fun little project I made over the August long weekend. It’s a parser and interpreter for the “Tiny Student Language”, a sublanguage of Racket. I made it as an accessible, high-level demonstration of how programming languages work. As such, it has very few built-in types and functions. However, it is still capable of correctly evaluating recursive and higher-order functions, and, theoretically, can traverse trees and graphs using mutually-recursive functions (this would be rather ugly and inefficient due to the absence of define-struct and local though). I don’t plan on adding new features to TSL in the future, so as to keep it simple, but I would like to expand its error handling, so imperfect code doesn’t cause an instant crash.\n","date":1596499200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1596499200,"objectID":"e63301437def4ac9b2cdb093ed6cd92e","permalink":"https://alexdsteele.com/project/tsl-interpreter/","publishdate":"2020-08-04T00:00:00Z","relpermalink":"/project/tsl-interpreter/","section":"project","summary":"Interpreter for a toy sublanguage of Racket.","tags":["Programming Languages","Python"],"title":"TSL Interpreter","type":"project"},{"authors":[],"categories":[],"content":"UBC Course Monitor is a web application that I built to help fellow UBC students find open seats in courses they want to take. Users can sign up to monitor any course section publically listed on the University of British Columbia’s Student Services Centre. Once they add the course to their list, they will receive an email notification when a seat opens up. The backend of the site was built using the Django framework and uses a Celery queue to do background monitoring. The application is deployed on Heroku and uses a PostgreSQL database to manage users and courses.\n","date":1594857600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594857600,"objectID":"544991af36a37204d4fce32078f2dcd2","permalink":"https://alexdsteele.com/project/ubc-course-monitor/","publishdate":"2020-07-16T00:00:00Z","relpermalink":"/project/ubc-course-monitor/","section":"project","summary":"Web application that monitors courses at UBC for seat openings.","tags":["Django","Python","Web Development"],"title":"UBC Course Monitor","type":"project"},{"authors":[],"categories":[],"content":"My primary role in UBC Rocket is contributing to the development of our rockets’ ground station software, which is used to remotely control the functioning of flight-critical and data collection electronics onboard and display any data received from the rocket. It is developed in Python using PyQt5 as a GUI framework. I optimized the ground station’s mapping functionality to allow it to update in real-time by implementing multithreading. I also designed and implemented an automated unit- and integration-testing framework using PyTest to ensure code correctness.\n","date":1579737600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579737600,"objectID":"96d38aa12ee5d74188acc20cf4fd3227","permalink":"https://alexdsteele.com/project/ubc-rocket-ground-station/","publishdate":"2020-01-23T00:00:00Z","relpermalink":"/project/ubc-rocket-ground-station/","section":"project","summary":"Ground station code for remote control of onboard electronics.","tags":["Python","PyQt"],"title":"UBC Rocket Ground Station","type":"project"}]