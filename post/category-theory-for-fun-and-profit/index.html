<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=author content="Alex Steele"><meta name=description content="A dive into the design of my `rand-functors` crate and discussion of the value of the more &#34;theoretical&#34; areas of CS."><link rel=alternate hreflang=en-us href=https://alexdsteele.com/post/category-theory-for-fun-and-profit/><meta name=theme-color content="#3f51b5"><script src=/js/mathjax-config.js></script>
<link rel=stylesheet href=/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css media=print onload='this.media="all"'><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css integrity="sha512-W0xM4mr6dEP9nREo7Z9z+9X70wytKvMGeDsj7ps2+xg5QPrEBXC8tAW1IFnzjR6eoJ90JmCnFzerQJTLzIEHjA==" crossorigin=anonymous media=print onload='this.media="all"'><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script>
<link rel=stylesheet href=/css/wowchemy.c2cf76037e1963fc86d3b5f4d2d05349.css><link rel=stylesheet href=/css/libs/chroma/github-light.min.css title=hl-light media=print onload='this.media="all"'><link rel=stylesheet href=/css/libs/chroma/dracula.min.css title=hl-dark media=print onload='this.media="all"' disabled><script async src="https://www.googletagmanager.com/gtag/js?id=G-71FMFPZ67J"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}function trackOutboundLink(e,t){gtag("event","click",{event_category:"outbound",event_label:e,transport_type:"beacon",event_callback:function(){t!=="_blank"&&(document.location=e)}}),console.debug("Outbound link clicked: "+e)}function onClickCallback(e){if(e.target.tagName!=="A"||e.target.host===window.location.host)return;trackOutboundLink(e.target,e.target.getAttribute("target"))}gtag("js",new Date),gtag("config","G-71FMFPZ67J",{}),gtag("set",{cookie_flags:"SameSite=None;Secure"}),document.addEventListener("click",onClickCallback,!1)</script><link rel=manifest href=/manifest.webmanifest><link rel=icon type=image/png href=/media/icon_hua290f4412f247f04a1fefae38f5cd580_85566_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/media/icon_hua290f4412f247f04a1fefae38f5cd580_85566_180x180_fill_lanczos_center_3.png><link rel=canonical href=https://alexdsteele.com/post/category-theory-for-fun-and-profit/><meta property="twitter:card" content="summary"><meta property="og:site_name" content="Alex Steele"><meta property="og:url" content="https://alexdsteele.com/post/category-theory-for-fun-and-profit/"><meta property="og:title" content="Category Theory for Fun and Profit | Alex Steele"><meta property="og:description" content="A dive into the design of my `rand-functors` crate and discussion of the value of the more &#34;theoretical&#34; areas of CS."><meta property="og:image" content="https://alexdsteele.com/media/icon_hua290f4412f247f04a1fefae38f5cd580_85566_512x512_fill_lanczos_center_3.png"><meta property="twitter:image" content="https://alexdsteele.com/media/icon_hua290f4412f247f04a1fefae38f5cd580_85566_512x512_fill_lanczos_center_3.png"><meta property="og:locale" content="en-us"><meta property="article:published_time" content="2024-04-07T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-07T00:00:00+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://alexdsteele.com/post/category-theory-for-fun-and-profit/"},"headline":"Category Theory for Fun and Profit","datePublished":"2024-04-07T00:00:00Z","dateModified":"2024-04-07T00:00:00Z","author":{"@type":"Person","name":"Alex Steele"},"publisher":{"@type":"Organization","name":"Alex Steele","logo":{"@type":"ImageObject","url":"https://alexdsteele.com/media/icon_hua290f4412f247f04a1fefae38f5cd580_85566_192x192_fill_lanczos_center_3.png"}},"description":"A dive into the design of my `rand-functors` crate and discussion of the value of the more \"theoretical\" areas of CS."}</script><title>Category Theory for Fun and Profit | Alex Steele</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents class=page-wrapper data-wc-page-id=b630897449f9ba73756fd728ca0cc64c><script src=/js/wowchemy-init.min.613040fe4f2c0f007b4dcb64404201cb.js></script><aside class=search-modal id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=# aria-label=Close><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search class=form-control aria-label=Search...></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><div class=page-header><header class=header--fixed><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container-xl><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Alex Steele</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar-content aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Alex Steele</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class=nav-link href=/#about><span>Home</span></a></li><li class=nav-item><a class=nav-link href=/#experience><span>Experience</span></a></li><li class=nav-item><a class=nav-link href=/#projects><span>Projects</span></a></li><li class=nav-item><a class=nav-link href=/#honours><span>Honours and Awards</span></a></li><li class=nav-item><a class=nav-link href=/#contact><span>Contact</span></a></li><li class=nav-item><a class="nav-link active" href=/post><span>Blog</span></a></li><li class=nav-item><a class=nav-link href=/reading><span>Reading</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=# aria-label=Search><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class=nav-link data-toggle=dropdown aria-haspopup=true aria-label="Display preferences"><i class="fas fa-moon" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span></a>
<a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span></a>
<a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav></header></div><div class=page-body><article class=article><div class="article-container pt-3"><h1>Category Theory for Fun and Profit</h1><p class=page-subtitle>or, The Design of <code>rand-functors</code></p><div class=article-metadata><span class=article-date>2024-04-07</span>
<span class=middot-divider></span>
<span class=article-reading-time>10 min read</span></div></div><div class=article-container><div class=article-style><p>Algorithms for zero-sum imperfect-information games are a longstanding interest of mine. I&rsquo;ve got a couple of hobby projects in that area which I work on whenever I have free time. A class of strategies I often use as a starting point for such projects is model-based search. This typically requires a good simulator of the game, which I often end up needing to write myself.</p><p>I&rsquo;m currently writing a simulator library for a game in Rust, with plans to expose a Python API through <a href=https://pyo3.rs/ target=_blank rel=noopener>PyO3</a> for rapid experimentation (PyO3 has rapidly become one of my favourite libraries&mdash;my days of fighting pybind11 might just be over). I want to make my library as performant as possible. I don&rsquo;t know what algorithms will work best, but I want online search to be feasible at a reasonable depth.</p><p>In these sorts of projects, I often find myself avoiding programming in a purely object-oriented or purely functional paradigm. Each has its merits but they share a drawback: indirection. A virtual method call requires the use of an indirect call Assembly instruction since the address of the desired function is not known at compile-time. It also prevents any sort of inlining. The same applies to lambda functions in functional paradigms. The latter group also tends to rely on many heap allocations which are later garbage-collected. None of these properties are acceptable in terms of performance. Instead, I try to adopt whatever architecture will work best in a given scenario, whether it fits into a particular paradigm or not.</p><p>With these constraints in mind, I was faced with something of a dilemma when figuring out how to generate the next nodes in the game tree given a current node. You see, I wanted my simulator to be useful for both evaluation and exploration. In the former use case, I&rsquo;d want it to quickly sample one possible outcome of a random process. In the latter, I&rsquo;d want all possible outcomes, so I could construct the game tree properly. These goals resulted in two functions that (drastically simplified) looked something like these:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rand</span>::<span class=n>prelude</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>next_state</span><span class=p>(</span><span class=k>mut</span><span class=w> </span><span class=n>state</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>u8</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>state</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>state</span><span class=p>.</span><span class=n>wrapping_add</span><span class=p>(</span><span class=n>random</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>random</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>state</span><span class=w> </span><span class=o>%=</span><span class=w> </span><span class=mi>3</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>state</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>next_states</span><span class=p>(</span><span class=n>state</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Vec</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>out</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=o>..=</span><span class=mi>255</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>r</span><span class=o>|</span><span class=w> </span><span class=n>state</span><span class=p>.</span><span class=n>wrapping_add</span><span class=p>(</span><span class=n>r</span><span class=p>)).</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>out</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>out</span><span class=p>.</span><span class=n>iter</span><span class=p>().</span><span class=n>copied</span><span class=p>().</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>i</span><span class=o>|</span><span class=w> </span><span class=n>i</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>3</span><span class=p>).</span><span class=n>collect</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>out</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>These two functions may seem different enough, but upon closer inspection, one can find common behaviour. Note how both sum their input with some <code>u8</code> with a <code>wrapping_add</code> and then reduce modulo 3 if some <code>bool</code> is true. The only differences relate to where those <code>u8</code> and <code>bool</code> values come from. In <code>next_state</code>, they are random, but in <code>next_states</code>, all possible values are looped over. The former is used for quick evaluation; the latter is used for complete exploration. However, the process remains the same, and that worries me.</p><p>Since the same process is described in code twice, the above listing flies in the face of the principle of DRY: &ldquo;Don&rsquo;t repeat yourself.&rdquo; This may seem like unproductive fretting over writing the cleanest possible code and, in this example, it probably is. But in my actual codebase, sharing this process description meant paired chains of helper functions operating on parameters of types <code>State</code> and <code>Vec&lt;State></code> respectively. These chains of functions were tightly coupled to each other&mdash;a change in the <code>State</code> version of a function almost always induced a change in the <code>Vec&lt;State></code> version. It also meant that, if I wanted to add the option to produce a <code>HashMap&lt;State, usize></code> or employ some clever strategy for collecting a sample of some fixed size, I would need to create a third set of duplicate functions.</p><p>I wanted some way to abstract over both sampling from a distribution and collecting its possible outcomes in a <code>Vec</code> or a <code>HashMap</code>. I spent a good couple of hours thinking about the problem during my long run that afternoon. Eventually, I made a connection that I wouldn&rsquo;t have expected.</p><p>Last fall, I took a course on Programming Languages Theory (CPSC 311) taught by Professor <a href=https://www.cs.ubc.ca/~rxg/ target=_blank rel=noopener>Ron Garcia</a>. In the course, we made extensive use of monads to abstract out effectful parts of our languages and keep our interpreters simple (Ron insistently called monads &ldquo;effect abstractions&rdquo; for this reason). What I thought I wanted was some sort of monad that could abstract over these different behaviours and return types, which I could implement using Rust&rsquo;s trait system and monomorphize away at compile time.</p><p>After a good amount of category theory review and some valuable input from Ron and from my old friend <a href=https://passingti.me/ target=_blank rel=noopener>Sean Bocirnea</a> (whom I&rsquo;m sure could have done this himself in fewer attempts), I was able to put together a first-pass implementation.</p><p>It turned out what I actually needed was something between a <a href=https://en.wikipedia.org/wiki/Functor_%28functional_programming%29 target=_blank rel=noopener>functor</a> and an <a href=https://en.wikipedia.org/wiki/Applicative_functor target=_blank rel=noopener>applicative functor</a> (monads are a special case of applicatives). In short, I needed a collection of some arbitrary inner type which I could both create from a single instance of the inner type (<code>Functor::pure</code>) and map over (<code>Functor::fmap</code>). The names &ldquo;functor&rdquo;, <code>pure</code>, and <code>fmap</code> are needlessly opaque for our purposes here. Here is a concrete example of implementations of those methods for lists in Python:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>list_fmap</span><span class=p>(</span><span class=n>f</span><span class=p>,</span> <span class=n>lox</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>f</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>lox</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>list_pure</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>[</span><span class=n>x</span><span class=p>]</span>
</span></span></code></pre></div><p>These functors could be used to contain the state for a random process. A version of the <a href=https://refactoring.guru/design-patterns/strategy target=_blank rel=noopener>Strategy pattern</a> would determine which functor should be created and operated on (<code>RandomStrategy::Functor</code>), as well as how random events should be handled (<code>RandomStrategy::fmap_rand</code>). Decoupling <code>fmap_rand</code> from individual <code>Functor</code> implementations was a major breakthrough for me in the design. This allowed the use of the same containers (like <code>Vec</code>) for multiple strategies, such as listing all possible outcomes or a fixed sample size of possible outcomes.</p><p>In the end, this is the interface I ended up with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>RandomStrategy</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Functor</span><span class=o>&lt;</span><span class=n>I</span>: <span class=nc>Inner</span><span class=o>&gt;</span>: <span class=nc>Functor</span><span class=o>&lt;</span><span class=n>I</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Required methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>fmap</span><span class=o>&lt;</span><span class=n>A</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=n>A</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span>: <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>func</span>: <span class=nc>F</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>fmap_rand</span><span class=o>&lt;</span><span class=n>A</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>R</span>: <span class=nc>RandomVariable</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span>: <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rng</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>Rng</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>func</span>: <span class=nc>F</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=k>where</span><span class=w> </span><span class=n>Standard</span>: <span class=nc>Distribution</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Functor</span><span class=o>&lt;</span><span class=n>I</span>: <span class=nc>Inner</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Required method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>pure</span><span class=p>(</span><span class=n>i</span>: <span class=nc>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Inner</span>: <span class=nb>Clone</span> <span class=o>+</span><span class=w> </span><span class=nb>Eq</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>Hash</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nb>PartialEq</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>RandomVariable</span>: <span class=nb>Sized</span>
</span></span><span class=line><span class=cl><span class=nc>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Standard</span>: <span class=nc>Distribution</span><span class=o>&lt;</span><span class=bp>Self</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Required method
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>sample_space</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>impl</span><span class=w> </span><span class=nb>Iterator</span><span class=o>&lt;</span><span class=n>Item</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>Self</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This looks like a lot, but it&rsquo;s fairly easy to break down. A <code>RandomStrategy</code> abstracts over different approaches to handling a point in a process where randomness plays a role. Associated with a <code>RandomStrategy</code> is a <code>Functor</code>, which acts as a container for an <code>Inner</code>, which is just the type that the original random process was operating on. <code>Functors</code> have the <code>pure</code> method we alluded to earlier to begin computations. Also associated with a <code>RandomStrategy</code> are <code>fmap</code> and <code>fmap_rand</code> functions, which take a <code>Functor</code> and apply a function operating on the inner of a <code>Functor</code> and (in the case of <code>fmap_rand</code>) an arbitrary <code>RandomVariable</code>. A <code>RandomVariable</code> is just a type that supports sampling from the <code>Standard</code> distribution and enumerating all possible outcomes using its <code>sample_space</code> associated function.</p><p>The definition of <code>fmap</code> as an associated function of a <code>RandomStrategy</code>, rather than a method of a <code>Functor</code>, is due to a limitation of Rust&rsquo;s type system. Ideally, we&rsquo;d want something like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>trait</span><span class=w> </span><span class=n>Functor</span><span class=o>&lt;</span><span class=n>I</span>: <span class=nc>Inner</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Required methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>fn</span> <span class=nf>pure</span><span class=p>(</span><span class=n>i</span>: <span class=nc>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>fmap</span><span class=o>&lt;</span><span class=n>A</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=n>A</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span>: <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>func</span>: <span class=nc>F</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Unfortunately, <code>Self</code> is equivalent to <code>Functor&lt;I></code>, not just <code>Functor</code>. This makes defining <code>fmap</code> as a method on a <code>Functor</code> impossible at the moment. This was another issue I struggled with before arriving at the above design. I only got here in <a href=https://github.com/ADSteele916/rand-functors/releases/tag/v0.3.0 target=_blank rel=noopener>v0.3.0</a>; prior versions used a different hack, borrowed from the <a href=https://docs.rs/higher/latest/higher/ target=_blank rel=noopener><code>higher</code></a> crate, which proved to be unsound.</p><p>Here are the <code>Functor</code> implementations for both &ldquo;raw&rdquo; <code>Inner</code> implementors and vectors of some <code>Inner</code> implementor:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>impl</span><span class=o>&lt;</span><span class=n>I</span>: <span class=nc>Inner</span><span class=o>&gt;</span><span class=w> </span><span class=n>Functor</span><span class=o>&lt;</span><span class=n>I</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>I</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>pure</span><span class=p>(</span><span class=n>i</span>: <span class=nc>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>I</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>i</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=o>&lt;</span><span class=n>I</span>: <span class=nc>Inner</span><span class=o>&gt;</span><span class=w> </span><span class=n>Functor</span><span class=o>&lt;</span><span class=n>I</span><span class=o>&gt;</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>I</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>pure</span><span class=p>(</span><span class=n>i</span>: <span class=nc>I</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=fm>vec!</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>And here are <code>RandomStrategy</code> implementations that use those <code>Functor</code> implementors:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Sampler</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>RandomStrategy</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Sampler</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Functor</span><span class=o>&lt;</span><span class=n>I</span>: <span class=nc>Inner</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>I</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>fmap</span><span class=o>&lt;</span><span class=n>A</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=n>A</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span>: <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>func</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>func</span><span class=p>(</span><span class=n>f</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>fmap_rand</span><span class=o>&lt;</span><span class=n>A</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>R</span>: <span class=nc>RandomVariable</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>FnOnce</span><span class=p>(</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span>: <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>rng</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>Rng</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>func</span>: <span class=nc>F</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Standard</span>: <span class=nc>Distribution</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>func</span><span class=p>(</span><span class=n>f</span><span class=p>,</span><span class=w> </span><span class=n>rng</span><span class=p>.</span><span class=n>gen</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Enumerator</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>RandomStrategy</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>Enumerator</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>type</span> <span class=nc>Functor</span><span class=o>&lt;</span><span class=n>I</span>: <span class=nc>Inner</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>Vec</span><span class=o>&lt;</span><span class=n>I</span><span class=o>&gt;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>fmap</span><span class=o>&lt;</span><span class=n>A</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=n>A</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=o>&gt;</span><span class=p>(</span><span class=n>f</span>: <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>func</span>: <span class=nc>F</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span><span class=p>.</span><span class=n>into_iter</span><span class=p>().</span><span class=n>map</span><span class=p>(</span><span class=n>func</span><span class=p>).</span><span class=n>collect</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=cp>#[inline]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>fmap_rand</span><span class=o>&lt;</span><span class=n>A</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>B</span>: <span class=nc>Inner</span><span class=p>,</span><span class=w> </span><span class=n>R</span>: <span class=nc>RandomVariable</span><span class=p>,</span><span class=w> </span><span class=n>F</span>: <span class=nb>Fn</span><span class=p>(</span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>R</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>B</span><span class=o>&gt;</span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span>: <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>_</span>: <span class=kp>&amp;</span><span class=nc>mut</span><span class=w> </span><span class=k>impl</span><span class=w> </span><span class=n>Rng</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>func</span>: <span class=nc>F</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Self</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>where</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>Standard</span>: <span class=nc>Distribution</span><span class=o>&lt;</span><span class=n>R</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>f</span><span class=p>.</span><span class=n>into_iter</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>flat_map</span><span class=p>(</span><span class=o>|</span><span class=n>a</span><span class=o>|</span><span class=w> </span><span class=n>R</span>::<span class=n>sample_space</span><span class=p>().</span><span class=n>map</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>|</span><span class=n>r</span><span class=o>|</span><span class=w> </span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>clone</span><span class=p>(),</span><span class=w> </span><span class=n>r</span><span class=p>)))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>)</span><span class=o>|</span><span class=w> </span><span class=n>func</span><span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>collect</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>The most complicated parts of these implementations are the signatures. Generic programming&rsquo;s power is only matched by its verbosity. However, if one looks at the actual code that&rsquo;s getting run, there&rsquo;s nothing all that surprising. If one looks at the implementations of <code>Functor&lt;I> for I</code> or <code>Sampler</code>, the behaviour is exactly what would be expected&mdash;they just apply the function, passing a randomly-generated <code>RandomVariable</code> when needed. <code>Functor&lt;I> for Vec&lt;I></code> and <code>Enumerator</code> are a bit more complicated, but can be parsed with minimal trouble by anyone with experience using Rust&rsquo;s iterators. They just map over the Cartesian product of the existing <code>Inner</code> elements and, in the case of <code>fmap_rand</code>, all possible values of the <code>RandomVariable</code> implementor being operated on by <code>func</code>.</p><p>With this abstraction, our old <code>next_state</code> and <code>next_states</code> functions can just become:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>use</span><span class=w> </span><span class=n>rand</span>::<span class=n>prelude</span>::<span class=o>*</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>use</span><span class=w> </span><span class=n>rand_functors</span>::<span class=p>{</span><span class=n>Functor</span><span class=p>,</span><span class=w> </span><span class=n>RandomStrategy</span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>fn</span> <span class=nf>next_state</span><span class=o>&lt;</span><span class=n>S</span>: <span class=nc>RandomStrategy</span><span class=o>&gt;</span><span class=p>(</span><span class=n>state</span>: <span class=kt>u8</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>S</span>::<span class=n>Functor</span><span class=o>&lt;</span><span class=kt>u8</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Functor</span>::<span class=n>pure</span><span class=p>(</span><span class=n>state</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span>::<span class=n>fmap_rand</span><span class=p>(</span><span class=n>out</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>thread_rng</span><span class=p>(),</span><span class=w> </span><span class=o>|</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>s</span><span class=p>.</span><span class=n>wrapping_add</span><span class=p>(</span><span class=n>r</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>out</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>S</span>::<span class=n>fmap_rand</span><span class=p>(</span><span class=n>out</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=n>thread_rng</span><span class=p>(),</span><span class=w> </span><span class=o>|</span><span class=n>s</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=o>|</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=o>%</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>s</span><span class=w> </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>out</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>This new <code>next_state</code> function is able to encode the same process as the two old functions, with some added syntactic overhead. Its true strength lies in its callers&rsquo; ability to switch between the behaviour of either of the old functions using Rust&rsquo;s <a href=https://blog.rust-lang.org/2021/09/09/Rust-1.55.0.html#dedication target=_blank rel=noopener>&ldquo;Turbofish&rdquo;</a> syntax. The old <code>next_state(s)</code> is equivalent to <code>next_state::&lt;Sampler>(s)</code> and the old <code>next_states(s)</code> is equivalent to <code>next_state::&lt;Enumerator>(s)</code>. The crucial detail which makes all this worthwhile is that Rust&rsquo;s generics are monomorphized at compile time. All instances of <code>S</code> will become <code>Sampler</code> and calls to its associated functions can be <a href=https://twitter.com/ManishEarth/status/936084757212946432 target=_blank rel=noopener>aggressively inlined</a>. In the end, an optimizing compiler can often output the exact same machine code as it did for the original functions, making <code>RandomStrategy</code> a zero-cost abstraction.</p><p>One could easily argue that this is just adding an unnecessary and somewhat leaky abstraction. When using <code>rand-functors</code>, developers need to wrap most computations in calls to <code>fmap</code> and <code>fmap_rand</code>. They will also likely need to modify many of their method signatures to consume and produce functors instead of inners. I agree that in our trivial example of <code>next_state</code> and <code>next_states</code>, the use of <code>rand_functors</code> is probably unnecessary. But in larger, more complex random processes, the abstraction demonstrates its usefulness.</p><p>This crate&rsquo;s true value, in my experience using it, is its ability to localize changes. I originally planned on using <code>Sampler</code> and <code>Enumerator</code> for my model-based search implementation. However, I realized that my random processes typically resulted in duplicate states, causing the vectors produced by the <code>Enumerator</code> strategies to grow unnecessarily long. This led me to believe a <code>HashMap</code> might be better instead. By designing a new <code>Counter</code> strategy, with a <code>HashMap&lt;I, usize></code> as its functor, I was able to test this theory extremely quickly. I swapped <code>Enumerator</code> for <code>Counter</code> and ran my benchmarks, confident that each strategy was being run as efficiently as possible. That&rsquo;s the true power of a zero-cost abstraction.</p><p>This entire process reinforced my belief in the importance of maintaining knowledge in a broad range of CS fields. Far too often, I see peers of mine in the CS department thumbing their noses at certain courses. I know someone who has taken Artificial Intelligence, Machine Learning and Data Mining, Intelligent Systems, Computer Vision, Natural Language Processing, and Advanced Machine Learning (CPSC 322, 340, 422, 425, 436N, and 440, for any UBC students). However, he categorically ruled out ever taking Programming Languages Theory because he &ldquo;didn&rsquo;t see [himself] ever using it.&rdquo; To each his own, I suppose, but he and I work on quite similar problems and something in that course was rather useful to me.</p></div><div class=article-tags><a class="badge badge-light" href=/tag/academics/>Academics</a>
<a class="badge badge-light" href=/tag/software-engineering/>Software Engineering</a></div><div class="media author-card content-widget-hr"><a href=https://alexdsteele.com/><img class="avatar mr-3 avatar-circle" src=/authors/adsteele/avatar_hu4d45f55babcc58ef6837ef1d183ac340_1382119_270x270_fill_q100_lanczos_center.jpg alt="Alex Steele"></a><div class=media-body><h5 class=card-title><a href=https://alexdsteele.com/>Alex Steele</a></h5><h6 class=card-subtitle>Simulation Software Engineer</h6><p class=card-text>Physics and Electronics Simulations at Tesla</p><ul class=network-icon aria-hidden=true><li><a href=mailto:contact@alexdsteele.com><i class="fas fa-envelope"></i></a></li><li><a href=https://github.com/ADSteele916 target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://linkedin.com/in/alexdsteele target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li><li><a href=/uploads/Alex%20Steele%20Resume.pdf><i class="ai ai-cv"></i></a></li></ul></div></div></div></article></div><div class=page-footer><div class=container><footer class=site-footer><p class="powered-by copyright-license-text">© 2024 Alexander Steele.</p><p class=powered-by></p></footer></div></div><script src=/js/vendor-bundle.min.46271ef31da3f018e9cd1b59300aa265.js></script>
<script id=search-hit-fuse-template type=text/x-template>
    <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
    </div>
  </script><script src=https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin=anonymous></script>
<script id=page-data type=application/json>{"use_headroom":true}</script><script src=/js/wowchemy-headroom.c251366b4128fd5e6b046d4c97a62a51.js type=module></script>
<script src=/en/js/wowchemy.min.a6238d5886fa4a2f7cf92df25709326f.js></script></body></html>