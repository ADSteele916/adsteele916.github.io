<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Alex Steele</title><link>https://alexdsteele.com/</link><atom:link href="https://alexdsteele.com/index.xml" rel="self" type="application/rss+xml"/><description>Alex Steele</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Tue, 05 Apr 2022 00:00:00 +0000</lastBuildDate><image><url>https://alexdsteele.com/media/icon_hua290f4412f247f04a1fefae38f5cd580_85566_512x512_fill_lanczos_center_3.png</url><title>Alex Steele</title><link>https://alexdsteele.com/</link></image><item><title>Project Fëanor</title><link>https://alexdsteele.com/project/project-feanor/</link><pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate><guid>https://alexdsteele.com/project/project-feanor/</guid><description>&lt;p>Project Fëanor was my term project for PHYS 319: Electronics Laboratory. I designed a quadcopter using mostly 3D-printed parts and used the MSP430 microcontroller as a flight controller, while working within its limited 512 bytes of RAM and 16 kilobytes of memory. To control the four motors, I wrote C code that interfaced with an accelerometer over I2C and accepted commands from a laptop over UART.&lt;/p></description></item><item><title>Reading</title><link>https://alexdsteele.com/reading/</link><pubDate>Mon, 14 Mar 2022 00:00:00 +0000</pubDate><guid>https://alexdsteele.com/reading/</guid><description>&lt;p>In my free time, I enjoy reading books, primarily (but, by no means, exclusively) fantasy, science fiction, and historical non-fiction. Here are some of my favourites, in no particular order:&lt;/p>
&lt;ul>
&lt;li>J.R.R. Tolkien&amp;rsquo;s legendarium (&lt;em>The Hobbit&lt;/em>, &lt;em>The Lord of the Rings&lt;/em>, &lt;em>The Silmarillion&lt;/em>, &lt;em>The Children of Húrin&lt;/em>, &lt;em>Beren and Lúthien&lt;/em>, &lt;em>The Fall of Gondolin&lt;/em>, and &lt;em>Unfinished Tales of Númenor and Middle-Earth&lt;/em>)&lt;/li>
&lt;li>&lt;em>The Wheel of Time&lt;/em> series, by Robert Jordan&lt;/li>
&lt;li>Frank Herbert&amp;rsquo;s &lt;em>Dune&lt;/em> Saga&lt;/li>
&lt;li>Andy Weir&amp;rsquo;s works (&lt;em>The Martian&lt;/em>, &lt;em>Artemis&lt;/em>, and &lt;em>Project Hail Mary&lt;/em>)&lt;/li>
&lt;li>&lt;em>Animal Farm&lt;/em> and &lt;em>Nineteen Eighty-Four&lt;/em>, by George Orwell&lt;/li>
&lt;li>&lt;em>Hamlet&lt;/em> and &lt;em>Macbeth&lt;/em>, by William Shakespeare&lt;/li>
&lt;li>&lt;em>Pride and Prejudice&lt;/em>, by Jane Austen&lt;/li>
&lt;li>&lt;em>A Tale of Two Cities&lt;/em>, by Charles Dickens&lt;/li>
&lt;li>&lt;em>Moby-Dick&lt;/em>, by Herman Melville&lt;/li>
&lt;li>&lt;em>Pygmalion&lt;/em>, by George Bernard Shaw&lt;/li>
&lt;li>&lt;em>The Great Gatsby&lt;/em>, by F. Scott Fitzgerald&lt;/li>
&lt;li>&lt;em>To Kill a Mockingbird&lt;/em>, by Harper Lee&lt;/li>
&lt;li>&lt;em>Metternich: Strategist and Visionary&lt;/em>, by Wolfram Siemann&lt;/li>
&lt;li>&lt;em>The Guns of August&lt;/em>, by Barbara W. Tuchman&lt;/li>
&lt;li>&lt;em>The Second World War: A Complete History&lt;/em>, by Martin Gilbert&lt;/li>
&lt;li>&lt;em>The Years of Lyndon Johnson&lt;/em>, by Robert Caro&lt;/li>
&lt;li>&lt;em>Becoming&lt;/em>, by Michelle Obama&lt;/li>
&lt;li>&lt;em>A Promised Land&lt;/em>, by Barack Obama&lt;/li>
&lt;/ul></description></item><item><title>Au Delà</title><link>https://alexdsteele.com/project/au-dela/</link><pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate><guid>https://alexdsteele.com/project/au-dela/</guid><description>&lt;p>Our project explores the use of GPT-3&amp;rsquo;s comprehension of code semantics in the setting of CS education. It has two components: a semantic autograder for teachers and a suite of code conversion/documentation tools for students.&lt;/p>
&lt;h2 id="summary">Summary&lt;/h2>
&lt;h3 id="teacher">Teacher&lt;/h3>
&lt;p>The main functionality of our project is the semantic autograder. Classically, autograders rely on black-box testing. This approach obviously works well for tasks like grading problem sets and exams but falls short in some other settings. Studies show that active participation in lectures boosts learning outcomes. To encourage this, profs might have students submit code for autograding live in lectures to incentivize participation. However, this can backfire, as the autograder forces students to write perfect code while also being introduced to a topic for the first time, which distracts them from actually learning.&lt;/p>
&lt;p>Ideally, an autograder would be able to tell that a student is writing code that, while not necessarily correct, shows that they understand the problem and roughly know what a solution might look like. To fill this void, we designed a semantics-based autograder. It uses GPT-3 to look at the contents of a student&amp;rsquo;s code submission and determine how closely it resembles a solution for the given problem. The benefits of using a natural language model, rather than classical text parsing and diffing, to solve this problem are manifest. First, the semantic autograder is able to extract meaning, rather than just structure, from code. This prevents false negatives from similar-looking functions, which can easily arise when a course enforces a common template for certain functions. It also prevents false positives when a problem allows for extremely diverse solutions that can vary wildly from what the instructor expects while still solving the problem.&lt;/p>
&lt;h3 id="student">Student&lt;/h3>
&lt;p>In order to guide students in their code implementation and debugging process, our program offers 6 different functions. There are bug fixers, docstring generators and tools to improve code quality and conciseness by converting length for-loops into compact maps or list comprehensions. The docstring generator is very helpful for students to understand the functionality of cryptic and poorly documented code. Moreover, the time complexity calculator can be used as a revision tool by CS students.&lt;/p>
&lt;p>&lt;em>&lt;strong>Fix Code:&lt;/strong>&lt;/em> Fixes syntactical errors in python code&lt;/p>
&lt;p>&lt;em>&lt;strong>Time Complexity:&lt;/strong>&lt;/em> Computes the time complexity of submitted snippet&lt;/p>
&lt;p>&lt;em>&lt;strong>Py Docstring:&lt;/strong>&lt;/em> Generates a Doc string for code&lt;/p>
&lt;p>&lt;em>&lt;strong>Loop to PyStream:&lt;/strong>&lt;/em> Converts Python for loops into streams&lt;/p>
&lt;p>&lt;em>&lt;strong>Loop to List:&lt;/strong>&lt;/em> Deduces the functional programming solution for a given algorithmic solution&lt;/p>
&lt;p>&lt;em>&lt;strong>List to Loop:&lt;/strong>&lt;/em> Deduces the iterative solution for a complementary functional programming solution&lt;/p>
&lt;h2 id="technology">Technology&lt;/h2>
&lt;p>Our implementation uses OpenAI&amp;rsquo;s Python API and a Flask backend. We considered using Django but felt that it was unncessarily heavy for our use case.&lt;/p>
&lt;h2 id="running">Running&lt;/h2>
&lt;p>Unfortunately, OpenAI doesn&amp;rsquo;t allow projects using GPT-3 to be published without approval, which takes around two weeks. We are, however, allowed to share pre-generated results, as we did in our demonstration video. Additionally, if you have an API key, you are free to run our code and verify our results. Simply clone the repository, add your key as an environment variable named &lt;code>OPENAI_API_KEY&lt;/code>, and run &lt;code>comparisons/comparison_functions.py&lt;/code>. Here are the expected results:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">fibonacci/starter.py: (105.779, 48.065, -57.714); Passing = False
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fibonacci/submission_random_garbage.py: (4.357, 3.657, -0.7000000000000002); Passing = False
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fibonacci/submission_wrong_function.py: (25.971, 18.292, -7.6789999999999985); Passing = False
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fibonacci/submission_recur.py: (25.715, 33.526, 7.8110000000000035); Passing = True
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fibonacci/submission_invalid.py: (18.612, 37.666, 19.054); Passing = True
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fibonacci/submission_indent_error.py: (11.573, 60.106, 48.533); Passing = True
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">fibonacci/solution.py: (10.018, 57.529, 47.511); Passing = True
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bintree/starter.py: (14.276, 7.852, -6.4239999999999995); Passing = False
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bintree/submission_iterative.py: (1.316, 3.952, 2.636); Passing = True
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bintree/submission_alternative.py: (3.74, 5.479, 1.7389999999999999); Passing = True
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">bintree/solution.py: (1.539, 7.248, 5.7090000000000005); Passing = True
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As we can see, handing in either starter file fails, as does typing random Python code or solving the wrong problem. However, all of the partial attempts at a solution get credit, which is what we want.&lt;/p></description></item><item><title>Project Lance</title><link>https://alexdsteele.com/project/project-lance/</link><pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate><guid>https://alexdsteele.com/project/project-lance/</guid><description>&lt;p>In order to give myself some more tactile experience working with machine learning, I challenged myself to create a bot capable of competing in Generation I Pokemon battles. However, training the bot would still take forever with the only existing option - running a local Pokemon Showdown server and interfacing with it. To solve this problem, I devised Project Lance: a locally-run Python implementation of Generation I Pokemon battles. With it, I was able to run about 2000 full battles per second on my CPU, as opposed to the couple dozen I could run by interfacing with Showdown in that same time. To further improve training speed, I implemented a multicore evaluator for self-play. This allowed me to train a &lt;a href="https://en.wikipedia.org/wiki/Neuroevolution_of_augmenting_topologies" target="_blank" rel="noopener">NEAT&lt;/a> model to play optimally on a simplified version of the full battle engine.&lt;/p></description></item><item><title>Spacetime Calculator</title><link>https://alexdsteele.com/project/spacetime-calculator/</link><pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate><guid>https://alexdsteele.com/project/spacetime-calculator/</guid><description>&lt;p>This Swing application allows users to plot events in two-dimensional spacetime. It demonstrates how events transform between reference frames, and how concepts such as simultaneity or two events being in the same place are frame-dependent. Additionally, it allows users to calculate how far two events are from each other in spacetime; whether they are timelike, spacelike, or null separated; and whether they appear to be simultaneous or in the same place in a given frame.&lt;/p></description></item><item><title>TSL Interpreter</title><link>https://alexdsteele.com/project/tsl-interpreter/</link><pubDate>Tue, 04 Aug 2020 00:00:00 +0000</pubDate><guid>https://alexdsteele.com/project/tsl-interpreter/</guid><description>&lt;p>This is just a fun little project I made over the August long weekend. It&amp;rsquo;s a parser and interpreter for the &amp;ldquo;Tiny Student Language&amp;rdquo;, a sublanguage of &lt;a href="https://racket-lang.org/" target="_blank" rel="noopener">Racket&lt;/a>. I made it as an accessible, high-level demonstration of how programming languages work. As such, it has very few built-in types and functions. However, it is still capable of correctly evaluating recursive and higher-order functions, and, theoretically, can traverse trees and graphs using mutually-recursive functions (this would be rather ugly and inefficient due to the absence of define-struct and local though). I don&amp;rsquo;t plan on adding new features to TSL in the future, so as to keep it simple, but I would like to expand its error handling, so imperfect code doesn&amp;rsquo;t cause an instant crash.&lt;/p></description></item><item><title>UBC Course Monitor</title><link>https://alexdsteele.com/project/ubc-course-monitor/</link><pubDate>Thu, 16 Jul 2020 00:00:00 +0000</pubDate><guid>https://alexdsteele.com/project/ubc-course-monitor/</guid><description>&lt;p>UBC Course Monitor is a web application that I built to help fellow UBC students find open seats in courses they want to take. Users can sign up to monitor any course section publically listed on the University of British Columbia&amp;rsquo;s Student Services Centre. Once they add the course to their list, they will receive an email notification when a seat opens up. The backend of the site was built using the Django framework and uses a Celery queue to do background monitoring. The application is deployed on Heroku and uses a PostgreSQL database to manage users and courses.&lt;/p></description></item></channel></rss>